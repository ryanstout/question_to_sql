datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  // previewFeatures = ["clientExtensions"]
}

generator pyclient {
  provider             = "prisma-client-py"
  interface            = "sync"
  recursive_type_depth = 5
}

model User {
  id       Int       @id @default(autoincrement())
  email    String    @unique
  name     String?
  password Password?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  question Question[]

  business   Business? @relation(fields: [businessId], references: [id])
  businessId Int?
}

// TODO we need to add a many-to-many relationship between businesses and users

model Password {
  hash String

  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId Int  @unique
}

enum FeedbackState {
  /// SQL could not be generated by ML
  UNGENERATED
  /// SQL failed to compile on the datasource side of things
  INVALID
  /// user has not yet indicated if the SQL is correct or not
  UNANSWERED
  /// user is not sure if the SQL is correct
  UNKNOWN
  /// user indicated the SQL is correct
  CORRECT
  /// user indicated the SQL is incorrect
  INCORRECT
}

// TODO should have openai state, since it can fail on that end
model Question {
  id       Int    @id @default(autoincrement())
  // TODO should add not-empty constraint https://stackoverflow.com/questions/7951120/sql-not-empty-instead-of-not-null
  question String

  dataSourceId Int
  dataSource   DataSource @relation(fields: [dataSourceId], references: [id], onDelete: Cascade)

  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId Int

  sql     String?
  userSql String?

  // should be unset initially, and result is only stored if the
  feedbackState FeedbackState @default(UNANSWERED)

  evaluationQuestion EvaluationQuestion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([id, userId])
}

enum EvaluationOperators {
  EQUALS
  CONTAINS
}

enum EvaluationStatus {
  UNREAD
  INCOMPLETE
  CORRECT
}

// TODO think about adding tags in the future
model EvaluationQuestionGroup {
  id Int @id @default(autoincrement())

  status EvaluationStatus @default(UNREAD)

  // exactly which question is "correct" is not important, all questions in the group are treated as inputs to training
  evaluationQuestions EvaluationQuestion[]

  dataSourceId Int
  dataSource   DataSource @relation(fields: [dataSourceId], references: [id])

  correctSql       String?
  results          Json?
  assertionColumns Json?

  // TODO need a list of result column assertions

  // some examples may contain a partial result set we want to assert against
  resultOperator EvaluationOperators @default(EQUALS)
  notes          String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// TODO think on automated audit trail when the `sql` changes due to model adjustments, maybe DB trigger to handle this?
model EvaluationQuestion {
  id Int @id @default(autoincrement())

  evaluationQuestionGroupId Int
  evaluationQuestionGroup   EvaluationQuestionGroup @relation(fields: [evaluationQuestionGroupId], references: [id], onDelete: Cascade)

  // not all training questions have a source question, we could add questions directly
  fromQuestionId Int?
  fromQuestion   Question? @relation(fields: [fromQuestionId], references: [id])

  // for debugging purposes only
  generatedSchema String?
  generatedPrompt String?

  // TODO question should be unique
  question String
  // cache of the latest generated SQL from openai
  codexSql String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EvaluationResult {
  id Int @id @default(autoincrement())

  // array of evaluation question IDs
  successfulQuestions Json
  // array of evaluation question IDs
  failedQuestions     Json
  evaluatedAt         DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Business {
  id   Int    @id @default(autoincrement())
  name String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  dataSources DataSource[]
}

enum DataSourceType {
  SNOWFLAKE
  POSTGRES
}

model DataSource {
  id Int @id @default(autoincrement())

  // for user to identify the source
  name        String
  credentials Json
  type        DataSourceType

  business   Business? @relation(fields: [businessId], references: [id])
  businessId Int?

  dataSourceTableDescriptions DataSourceTableDescription[]
  Question                    Question[]
  DataSourceTableColumn       DataSourceTableColumn[]
  EvaluationQuestionGroup     EvaluationQuestionGroup[]
}

model DataSourceTableDescription {
  id Int @id @default(autoincrement())

  dataSource   DataSource @relation(fields: [dataSourceId], references: [id])
  dataSourceId Int

  // manually allow the user to skip this table
  skip Boolean @default(false)

  // store the FQN and use a application-level function to extract the target
  fullyQualifiedName String

  columns DataSourceTableColumn[]

  generatedSQLCache String?

  // TODO can we enforce JSON schema inside this JSONB array?
  // we could generate a bunch of different embedding and include as a JSON array
  embeddingsCache Json? @default("{}")

  @@unique([dataSourceId, fullyQualifiedName])
}

model DataSourceTableColumn {
  id Int @id @default(autoincrement())

  dataSource   DataSource? @relation(fields: [dataSourceId], references: [id])
  dataSourceId Int

  skip Boolean @default(false)

  // place to store distinct number of entries, etc and other analysis
  inspectionMetadata Json @default("{}")

  // core column description to be used to generate a SQL describe later on
  name    String
  type    String
  kind    String
  isNull  Boolean
  default String?

  // used in cardinality calculations
  distinctRows Int
  rows         Int

  extendedProperties Json

  // unsure *exactly* what the DB structure should look like here, so we can stuff
  // anything else we need in the extended properties, for example:
  // "primary key" String
  // "unique key" String
  // check      any
  // expression any
  // comment    any
  // "policy name": any

  embeddingsCache              Json                       @default("{}")
  dataSourceTableDescription   DataSourceTableDescription @relation(fields: [dataSourceTableDescriptionId], references: [id])
  dataSourceTableDescriptionId Int
}

// Simple cache for contentHash -> embedding so we don't have to rehit the openai api
model EmbeddingCache {
  id Int @id @default(autoincrement())

  // Hash of the string used to generate the embedding (so we can cache them)
  contentHash String

  // The embedding in npz format
  embedding Bytes
}
