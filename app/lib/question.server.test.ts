import { FeedbackState } from "@prisma/client"

import * as pythonBackend from "~/lib/python.server"
import {
  createQuestion,
  getResultsFromQuestion,
  updateQuestion,
} from "~/lib/question.server"

import {
  MOCKED_DATASOURCE_RESULTS,
  MOCKED_SQL_RESULT,
  mockPythonServer,
} from "test/python-mocks"

const dataSourceId = 1
const userId = 1

// TODO need to use test DB
// TODO need to mock data source
test("processes a new question", async () => {
  mockPythonServer()

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "What is the total number of orders?"
  )

  expect(questionResult.status).toBe("success")
  expect(questionResult.data).toBeNull()
  expect(questionResult.question.userSql).toBeNull()
  // TODO should create fixture for this
  expect(questionResult.question.sql).toBe("SELECT * FROM ORDER LIMIT 10")
})

test("updates a question sql", async () => {
  mockPythonServer()

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "What is the total number of orders?"
  )

  const updatedSql = "SELECT * FROM customers LIMIT 10"
  const updatedQuestion = await updateQuestion(
    questionResult.question,
    updatedSql
  )

  expect(updatedQuestion.question.userSql).toBe(updatedSql)
})

test("gets results from a question with custom user sql", async () => {
  const { runQuerySpy } = mockPythonServer()

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "What is the total number of orders?"
  )

  const updatedSql = "SELECT * FROM PLACES LIMIT 10"
  const updatedQuestion = await updateQuestion(
    questionResult.question,
    updatedSql
  )

  const results = await getResultsFromQuestion({
    questionRecord: updatedQuestion.question,
  })

  expect(results.status).toBe("success")
  expect(results.data).toEqual(MOCKED_DATASOURCE_RESULTS)

  const lastQueryCall = runQuerySpy.mock.calls.at(-1)!
  expect(lastQueryCall[1]).toEqual(updatedSql)
})

test("gets results from a question", async () => {
  mockPythonServer()

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "What is the total number of orders?"
  )

  const results = await getResultsFromQuestion({
    questionRecord: questionResult.question,
  })

  expect(results.status).toBe("success")
  expect(results.data).toEqual(MOCKED_DATASOURCE_RESULTS)
})

test("gets results from question ID", async () => {
  mockPythonServer()

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "What is the total number of orders?"
  )

  const results = await getResultsFromQuestion({
    questionId: questionResult.question.id,
  })

  expect(results.status).toBe("success")
  expect(results.data).toEqual(MOCKED_DATASOURCE_RESULTS)
})

test("marks the question as ungenerated if openai fails", async () => {
  const pythonRequestSpy = vi
    .spyOn(pythonBackend, "pythonRequest")
    // TODO should add more refined errors here when we've figured them out
    .mockRejectedValueOnce(new SyntaxError("bad json from server"))

  const questionResult = await createQuestion(
    userId,
    dataSourceId,
    "This is a question that would fail to generate"
  )

  expect(questionResult.status).toBe("error")
  expect(questionResult.data).toBeNull()

  expect(questionResult.question.sql).toBeNull()
  expect(questionResult.question.feedbackState).toBe(FeedbackState.UNGENERATED)
})

test("marks the query as invalid if it fails to execute", async () => {
  const pythonRequestSpy = vi
    .spyOn(pythonBackend, "pythonRequest")
    // generate SQL properly, then throw an exception when the SQL is executed
    .mockResolvedValueOnce({ sql: MOCKED_SQL_RESULT })

  const createQuestionResult = await createQuestion(
    userId,
    dataSourceId,
    "This is a question that would fail to compile"
  )

  expect(createQuestionResult.status).toBe("success")
  expect(createQuestionResult.data).toBeNull()
  expect(createQuestionResult.question.sql).not.toBeNull()

  const runQuerySpy = vi
    .spyOn(pythonBackend, "runQuery")
    .mockRejectedValueOnce(new SyntaxError("snowflake compilation error"))

  const results = await getResultsFromQuestion({
    questionId: createQuestionResult.question.id,
  })

  // the second call should throw an error, which should trigger an error
  expect(results.status).toBe("error")
  expect(results.data).toBeNull()
  // SQL should be generated by the first call
  expect(results.question.sql).not.toBeNull()
  expect(results.question.feedbackState).toBe(FeedbackState.INVALID)

  // TODO this is not working properly, I wonder if a call is only recorded if it DOESN'T throw an exception
  // expect(pythonRequestSpy).toHaveBeenCalledTimes(2)
  expect(pythonRequestSpy).toHaveBeenCalledTimes(1)
})
